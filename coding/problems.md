---
title: 经典问题
categories:
  - Alogrithm
tags:
  - Alogrithm
  - Data Structure
  - Problems
date: 2024-01-06 18:32:01
updated: 2024-07-08 17:11:55
toc: true
mathjax: true
description: 
---

##  排序

-   排序：按照升序（降序）重新排列给定列表中的数据项
    -   键：在对记录排序时，需要选取的、作为排序的依据的一段信息
    -   排序算法评价
        -   基于键值比较（相较于比较部分键值而言）的排序算法时间效率上限即 $nlog^n$
        -   不同算法均有各自优势，适合不同场合
            -   逻辑结构：实现简单、时间效率高
            -   数据初序：随机排列、基本有序
            -   空间效率：内存少量高速数据、磁盘大量低速数据
        -   稳定性：键等值元素排序前后保序
            -   一般来说，稳定性差算法时间效率高
        -   在位性：除常量必要存储单元外，无序需要额外的存储空间

### 选择排序

-   选择排序
    -   遍历，不断更新得到剩余元素最小值，与正确位置元素交换位置
    -   遍历 n-1 轮，直到列表有序
-   算法特点
    -   对任何输入，选择排序键值比较均为 $\theta(n^2)$
    -   键交换次数仅为 $\theta(n)$
        -   选择排序此特性优于许多其他排序算法

### 冒泡排序

-   冒泡排序
    -   遍历，比较表中相邻元素，逆序则交换位置
        -   剩余元素中最大者将被“沉到”列表最后位置
    -   遍历 n-1 轮，直到列表有序
-   算法特点
    -   对任何输入，冒泡排序键值比较都是 $\Theta(n^2)$
    -   其交换次数取决于特定输入
        -   最坏情况是遇到降序排列数组，此时键交换次数同比较次数
    -   冒泡排序类似：选择排序 + 交换替代更新 + 最大优先

### 插入排序

-   插入排序：利用减一技术对数组 `A[0..n-1]` 进行排序
    -   假设对较小数组 `A[0..i-2]` 排序已经解决
    -   从右至左（方便将将元素右移）扫描有序子数组，直到遇到首个小于等于 `A[i-1]` 元素，将 `A[i-1]` 插入其后
-   算法特点
    -   插入排序是自顶向下基于递归思想，但是自底向上使用迭代实现算法效率更高
    -   算法时间效率
        -   算法基本操作是键值比较，比较次数依赖于特定输入
        -   最坏情况（递减数组）下：每轮比较次数都到达最大，此时键值比较次数 $\in \Theta(n^2)$
        -   最优情况（递增数组）下：每轮比较次数仅为 1，此时键值比较次数 $\in \Theta(n)$
        -   对随机序列：比较次数 $\in \Theta(n^2)$
        -   对基本有序列表，插入排序能保证良好性能

### *Shell Sort*

```c
ShellSort(A[0..n-1])
    // 用插入排序对给定数组排序
    // 输入：n个可排序元素构成数组
    // 输出：非降序排序数组
    h = 1
    while h < n/3
        h = h*3 + 1
        // 获取初始h值，之后每轮h变为1/3
    while h >= 1:
        for i = h to n-1:
            v = A[i]
            j = i - h
            while j >= 0 and A[j] > v do
                A[j] = A[j-h]
                j = j - h
            A[j+h] = v
        h = h/3
```

-   *Shell Sort*：基于 *h 有序*、插入排序的扩展
    -   使用插入排序对 *h 子数组* 独立排序，每次交换相隔 h 的元素
    -   h 逐渐减小到 1，Shell 排序退化（最后一轮）为插入排序
-   算法特点
    -   Shell排序全衡量子数组规模、有序性，更加高效
    -   子数组部分有序程度取决于 h 选择
        -   不同的 h 对算法效率有常数倍的变动，但是在实际应用中效果不明显
    -   Shell 排序难以准确描述在对于乱序数组性能

> - *h有序*：数组中任意间隔为 h 的元素都是有序的
> - -   可视为 h 个互相独立的有序数组 **编织** 在一起的数组
> - -   具有分离、局部有序的特点

### 归并排序

```c
Mergesort(A[0..n-1]):
    // 递归调用MergeSort对数组排序
    // 输入：可排序数组A[0..n-1]
    // 输出：非降序排列数组A[0..n-1]
    if n > 1:
        copy A[0..floor(n/2)-1] to B[0..floor(n/2)-1]
        copy A[floor(n/2)..n-1] to C[0..ceiling(n/2)-1]
        Mergesort(B[0..floor(n/2)-1])
        Mergesort(C[0..ceiling(n/2)-11])
        Merge(B, C, A)

Merge(B[0..p-1], C[0..q-1], A[0..p+q-1]):
    // 将两个有序数组合并为新的有序数组
    // 输入：有序数组B[0..p-1]、C[0..q-1]
    // 输出：存放有B、C中元素的有序数组A[0..p+q-1]
    while i < p and j < q:
        if B[i] <= C[j]
            A[k] = B[i]
            i = i + 1
        else:
            A[k] = C[j]
            j = j + 1
        k = k + 1
    if i == p:
        copy C[j..q-1] to A[k..p+q-1]
    else:
        copy B[i..p-1] to A[k..p+q-1]
```

-   归并排序：分治
    -   子问题：均分待排序数组 `A[0..n-1]`，对两个子数组递归排序
    -   合并子问题解：合并排序后的子数组为有序数组
-   算法特点
    -   算法时间效率
        -   最坏情况下比较次数 $\in \Theta(nlogn)$，为 $nlog_2n-n+1$，接近基于比较的排序算法理论上限
    -   相较于快排、堆排序
        -   比较次数稳定
        -   （常用实现）但需要线性额外空间
        -   而，在位实现过于复杂，只具有理论上意义
-   算法优化思路
    -   自底向上归并：自底向上依次归并 **相邻有序子数组对**
        -   这可以避免使用堆栈递归调用时时空开销
    -   多路归并：将数组划分为待排序的多个部分执行递归排序
        -   适合对存在二级存储空间的文件进行排序

### 快速排序

-   快速排序：分治
    -   对数组中元素重新排列，使得 `A[s]` 左边元素均小于 `A[s]`、`A[s]` 右边元素都大于等于 `A[s]`
        -   则 `A[s]` 已位于它在有序数组中的最终位置
    -   之后对 `A[s]` 左右子数组进行快速排序，直至数组有序
-   算法特点
    -   算法效率
        -   最优情况：分裂点都位于数组中点，算法比较次数为 $nlog_2n$
        -   最差情况：分裂点都趋于极端（逆序输入），算法比较次数 $\in \Theta(n^2)$
        -   平均：比较次数为 $2nlnn \approx 1.39nlog_2n$
        -   且算法内层循环效率非常高，在处理随机排列数组时，速度比合并排序快
    -   快速排序不稳定
        -   划分策略即分裂点选择对算法效率影响巨大，且任何分裂点算法均无法避免最差情况出现
        -   对随机数组排序性能的好坏，除与算法具体实现有关，还和计算机系统结构、数据类型有关
    -   空间效率：需额外堆栈存储未被排序的子数组参数
        -   可先对较短子数组排序使得堆栈大小降低到 $O(logn)$，但是仍差于堆排序的 $O(1)$
-   算法优化方向
    -   划分点选择策略
        -   随机快速排序：使用随机元素作为分裂点
        -   三平均划分法：以数组最左边、最右边、最中间的中位数作为划分点
    -   数据划分比较策略方法#TODO
        -   *Lomuto Partition Scheme*
        -   *Hoare Partition Scheme*
    -   子数组足够小时（`5 - 15`），改用插入排序

> - 快速排序实现：<https://baobaobear.github.io/post/20191007-qsort-talk-1/>

####    *Lomuto Partition*

```c
LomutoPartition(A[l..r])
    // 采用Lomuto算法，用首个元素作中轴划分数组
    // 输入：可排序数组A[0..n-1]的子数组A[l..r]
    // 输出：A[l..r]的划分、中轴位置
    p = A[l]
    s = l
    for i = l+1 to r
        if A[i] < p
            s = s+1
            swap(A[s], A[i])
    swap(A[l], A[s])
    return s
```

-   *Lomuto Partition*
    -   考虑子数组 `A[l..r]` 分为三段，按顺序排在中轴 p 之后
        -   小于 p 的元素，最后元素索引记为 s
        -   大于等于 p 的元素，最后元素索引记为 i
        -   未同 p 比较过元素
    -   从左至右扫描 `A[l..r]`，比较其中元素和 p 大小
        -   若 `A[i] >= p`，扩大大于等于 p 元素段
        -   若 `A[i] < p`，需要扩大小于等于 p 元素段

####    *Hoare Partition*

```c
HoarePartition(A[l..r])
    // 以首元素为中轴，对数组进行划分
    // 输入：可排序数组A[1..n]的子数组A[l..r]
    // 输出：A[l..r]的一个划分，返回分裂点位置
    p = A[l]
    i = l
    j = r+1
    repeat
        repeat i = i+1 until A[i] >= p
            // 这里i有可能越界，可以添加一个限位器
        repeat j = j-1 until j[i] <= p
            // 从左右两端都是遇到等于p的元素就停止扫描
            // 这样可以保证即使数组中有许多和p相等的元素
            // 也能够将数组划分得比较均匀
        swap(A[i], A[j])
            // 这样写没有关系，不需要在这里给调整i、j
            // 因为循环下一步就是调整i、j
    until i >= j
    swap(A[i], A[j])
        // 撤销算法最后一次交换
    swap(A[l], A[j])
    return j
```

-   *Hoare Partition*
    -   选择一个元素 p 作为中轴（最简单的，首个元素 `p=A[l]` ）
    -   从数组 `A[l..r]` 两端进行扫描，将扫描到的元素同中轴比较
        -   从左至右的扫描忽略小于中轴元素，直到遇到大于等于中轴元素停止（从第二个元素开始 `i=l+1` ）
        -   从右至左的扫描忽略大于中轴元素，直到遇到小于等于中轴元素停止(` j=r-1` )
    -   若扫描停止后
        -   两指针不相交 `i < j`，交换 `A[i]`、`A[j]`，置 `i=i+1`、`j=j-1`，继续扫描
        -   若指针相交 `i > j`，把中轴和 `A[j]` 交换即得到数组一个划分，分裂点为 `s=j`
        -   如果指针重合 `i==j`，此元素一定等于 p，也得到数组的一个划分，分裂点为 `s==i==j`

### 比较计数排序

```c
ComparisonCountingSort(A[0..n-1])
    // 用比较计数法排序
    // 输入：可排序数组A[0..n-1]
    // 输出：将A中可排序数组按照升序排列数组
    for i = 0 to n-1 do
        count[i] = 0
    for i = 0 to n-2 do
        for j = i+1 to n-1 do
            if A[i] < A[j]
                count[j] += 1
            else
                count[i] += 1
    for i = 0 to n-1 do
        S[count[i]] = A[i]
```

-   比较计数排序：输入增强变治
    -   遍历待排序列表中每个元素
    -   计算、记录列表中小于该元素的元素个数
    -   更新大于其的元素的小于元素的元素个数
-   算法特点
    -   时间效率：比较次数为 $n(n-1)/2$
    -   空间效率：占用线性数量的额外空间
    -   算法使得键值的可能移动次数最小化，能够直接将键值放在在有序数组最终位置

### 分布计数排序

```python
DistributionCountingSort(A[0..n-1], l, u):
    // 分布计数法排序，对元素来自有限范围整数的数组排序
    // 输入：数组[0..n-1]，数组中整数位于l、u间
    // 输出：A中元素构成非降序数组S[0..n-1]
    for j = 0 to u-l do
        D[j] = 0
    for i = 0 to n=1 do
        D[A[i]-l] += 1
    for j = 1 to u-l do
        D[j] += D[j-1]
        // 存储各元素最后出现索引+1
    for i = n-1 downto 0 do
        j = A[i] - l
        S[D[j]-1] = A[i]
        D[j] -= 1
        // 更新应该存储的位置，类似于压栈
    return S
```

-   分布计数排序
    -   扫描列表，计算、存储列表中元素出现频率于数组 `F[l..u]` 中
    -   再次扫描列表，根据值填入相应位置
-   算法特点
    -   利用了输入列表独特自然属性
        -   待排序元素需来自于某个已知小集合
    -   时间效率：元素值范围固定时，效率为线性
        -   不是基于比较的排序， 不受 $nlogn$ 限制
        -   空间换时间，可视为哈希表输入增强


##  查找

-   查找问题：在给定的集合、多重集（允许多个元素具有相同的值）中找给定值
    -   典型问题
        -   无序表查找
        -   有序表查找
        -   子串匹配
    -   解决思路
        -   输入增强、预处理
        -   分治（变治）剪枝
    -   说明
        -   没有任何一种查找算法在任何情况下都是最优的
            -   有些算法速度快，但是需要较多存储空间
            -   有些算法速度快，但是只适合有序数组
        -   查找算法没有稳定性问题，但会发生其他问题
            -   如果应用里的数据相对于查找次数频繁变化，查找问题必须结合添加、删除一起考虑
            -   必须仔细选择数据结构、算法，以便在各种操作的需求间达到平衡

### 无序线性表查找

-   无序线性表查找
    -   解决思路：输入增强
        -   预排序
        -   构建二叉树

### 有序线性表查找

-   有序线性表查找
    -   解决思路：利用有序性质 **减小问题规模**

####    折半查找/二分查找

```c
left, right = ...
while condition(search_space is not NULL):
    mid = (left + right) // 2
    if nums[mid] == target:
        // do something
    elif nums[mid] > target:
        // do something
    elif nums[mid] < target:
        // do somthing
```

-   二分查找：利用数组的有序性，通过对查找区间中间元素进行判断，缩小查找区间至一半大小
    -   依赖数据结构，需能够快速找到中间元素，如数组、二叉搜索树
    -   核心即比较中间元素和目标的大小关系、减小问题规模，需注意
        -   查找区间端点初值设置、更新逻辑
        -   中点选择
        -   循环条件、中止条件

####    插值查找

-   *Interpolation Search*：在折半查找的基础上预估目标键可能位置，缩小查找区间
    -   假设 *键值-键位置* 线性相关，则根据直线方程，估计查找键 $K$ 在 $A[l..r]$ 位置
        $$
        x = l + \left \lfloor \frac {(K-A[l])(r-l)} {A[r] - A[l]} \right \rfloor
        $$
-   算法特点
    -   即使数组值不是线性递增，也不会影响算法正确性，仅估计精度不高影响效率
    -   折半插值类似非参方法，只考虑秩（索引）方向
    -   插值查找类似参数方法，构建了秩（索引）和数组值模型，但是线性关系基于假设
        -   模型错误效率可能较折半查找效率底，即在数据分布偏差较大的情况下非参方法更优
        -   可以考虑抽样、构建模型，然后估计查找键位置
-   算法效率
    -   对随机列表，算法比较次数小于 $log_2log_n+1$
    -   最差情况，比较次数为线性，没有折半查找稳定
    -   Robert Sedgewick的Algorithms中研究表明，对较小文件折半查找更好，大文件、比较开销大插值查找更好

### 子串匹配
#TODO

####    *Horspool* 算法

####    *Boyer-Moore* 算法

####    *KMP* 算法

### *TopK* 问题

-   *TopK* 问题：寻找列表中第 k 小的元素
    -   采用快排划分思路，需要将给定列表根据某个值先行划分
        -   *Lumuto*划分算法

####    *Quick Select* 算法

```python
QuickSelect(A[l..r], k)
    // 用基于划分递归算法解决选择问题
    // 输入：可排序数组A[0..n-1]的子数组A[l..r]、整数k
    // 输出：A[l..r]中第k小元素
    s = Partition(A[l..r])
    if s = l+k-1
        return A[s]
    elif s > l+k-1
        QuickSelect(A[l..s-1], k)
    else
        QuickSelect(A[s+1..r], l+k-1-s)
```

-   *Quick Select* 算法：快排划分减治
    -   选择元素 `A[s]` 划分数组，`s` 为分割位置
        -   `s == k-1`：则划分点 `A[s]` 就是第 `k` 小元素
        -   `s < k-1`：数组右侧划分第 `k-s` 元素即为第 `k` 小元素
        -   `s > k-1`：数组左侧划分第 `k` 元素即为第 `k` 小元素
    -   重复直到找到划分点为第 `k` 小元素
-   算法特点
    -   时间效率：和划分算法有关（对 *Lomuto* 算法）
        -   最好情况下只需要划分一次即找到，需要比较 $n-1$ 次
        -   最坏情况下需要比较 $n(n-1)/2$ 次，这比直接基于排序更差
        -   数学分析表明，基于划分的算法平均情况下效率是线性的

##  组合问题

-   组合问题：寻找（明确地、隐含地）排列、组合对象，以满足特定条件并具有目标属性
    -   问题要点
        -   组合对象、组合方式：排列、组合（整数规划）、子集
        -   约束条件
        -   问题目标：价值最大化、成本最小化
    -   问题特点：从理论角度、实践角度而言，组合问题是计算领域最难的问题
        -   随着问题规模增大，组合对象数量增长极快
        -   没有一种已知算法，能在可接受的时间范围内精确的解决大部分组合问题，且被普遍认为不存在（未被证实）
            -   有些组合问题有高效求解算法，是幸运的例外
    -   典型问题
        -   背包问题：n 个重量、价值不同的物品，承重为 W 的背包可装载的最大价值
        -   装箱问题：n 个重量不同物品，全部装载所需的、承重为 W 的箱子的最小数量
        -   图着色问题：对给定图中顶点染色，使得相邻顶点颜色不同最少颜色数量
        -   划分问题：n 个正整数，判断是否可划分为和相等的两个子集
        -   子集和问题：n 个正整数，求满足和为 D 的子集
        -   币值最大化问题：n 个硬币，不相邻选择硬币的最大价值
        -   找零问题：n 种面值硬币，完成找零 D 元所需的最小硬币数量
        -   硬币收集问题：$n * m$ 格木板，每格可能放有硬币，从左上向下、向右移动到右下能收集到最大硬币数量
        -   n 皇后问题：将 n 个皇后放在 $n * n$ 的棋盘上，使得皇后之间不能相互攻击
        -   球桶问题：n 球放入 m 桶的不同情况数量
        -   全排列生成
        -   子集生成
    -   解决思路
        -   穷举搜索
        -   动态规划

> - 从抽象的角度看，旅行商问题、图填色问题也是组合问题的特例

###    背包问题

-   问题：给定 n 个重量为 $w_1, w_2, \cdots, w_n$ 价值为 $v_1, v_2, ..., vn$ 的物品和承重为 $W$ 的背包，求能够装进背包的最有价值物品子集

####    动态规划

$$
F(i, j) =
\left \{ \begin{array}{l}
    max\{F(i-1, j), v_i + F(i-1, j-w_i)\} & j-w_i \geqslant 0 \\
    F(i-1, j) & j-w_i \leqslant 0 \\
    0 & i=0 or j=0 (i, j \geqslant 0)
\end{array} \right.
$$

-   递推思路
    -   设 $F(i, j)$ 为由前 i 个物品、承重量为 j 的背包得到的最优解
    -   不包括第 i 个物品的子集中，最优子集价值为 $F(i-1, j)$
    -   包括第 i 个物品的子集中，最优子集是由该物品和前 i-1 个物品中能够放进承重量为 $j-w_i$ 的背包的最优子集组成，总价值为 $v_i + F(i-1, j-w_i)$
-   算法效率
    -   时间效率$\in \Theta(nW)$
    -   空间效率$\in \Theta(nW)$
    -   回溯求最优解组成效率$\in O(n)$

```c
Knapsack(Ws[1..n], Vs[1..n], W)
    // 动态规划求解背包问题
    // 输入：Ws[1..n]物品重量、Vs[1..n]物品价值，W背包承重
    // 输出：背包能够装载的最大价值
    for i = 0 to n do
        F[i, 0] = 0
    for j = 0 to W do
        F[0, j] = 0
        for i = 1 to n do
            if j >= Ws[i]:
                F[i, j] = max(F[i-1, j], Vs[i] + F[i-1, j-Ws[i])
                // 这里用于比较的F值，在之前的循环中已经确定
            else
                F[i, j] = F[i-1, j]
    return F[n, W]
```

-   剪枝
    -   按剩余物品单位价值剪枝
        -   考虑物品按照价值重量比 $v_i / w_i$ 降序排列
        -   第 i 层节点上界可取：$ub = v + (W - w)(v_{i+1} / w_{i+1})$
            -   $v$：已选物品价值
            -   $W - w$：背包剩余承重量
            -   $v_{i+1}/w_{i+1}$：剩余物品单位最大价值
        -   第 i 层节点更紧密上界可取：
            $ub = v + \sum_{k=i+1}^K v_k + (W - \sum_{k=1}^K w_k)v_K / w_K$

####    贪婪

-   贪婪思路
    -   考虑物品按照价值重量比 $r_i = v_i / w_i, i=1,2,\cdots,n$ 降序排列
    -   重复以下直到有序列表中不留下物品
        -   如果列表中当前物品可以装入，则放入背包并处理下个物品
        -   否则忽略，直接处理下个物品
-   优化思路
    -   调整方案 1：每次选择剩余物品中可行的、价值较大者
    -   *Sahni* 方案：限制装载物品数量上限 K，在子空间中确定最优解

### 币值最大化问题

-   币值最大化问题：N 个硬币，币值为正整数 $c_i, i=1, 2, \cdots, n$（币值不唯一），不相邻选择硬币，使得总价值最大

####    动态规划

$$
F(n) = max\{c_n + F(n-2), F(n-1)\}, n>1 \\
F(0) = 0, F(1) = c_1
$$

-   递推思路
    -   记前 i 枚硬币最大可选金额为 $F(i)$
    -   包含第 i 枚硬币时，最大可选金额为 $c_i + F(i-2)$
    -   不包含第 i 枚硬币时，最大可选金额为 $F(i-1)$
-   算法效率
    -   时间效率$\in \Theta(n)$
    -   空间效率$\in \Theta(n)$

```c
CoinRow(C[1..n])
    // 在所选硬币不相邻，从一排硬币中选择最大金额
    // 输入：C[1..n]保存n个硬币面值
    // 输出：可选硬币最大金额
    F[0] = 1
    F[1] = C[1]
    for i = 2 to n do
        F[i] = max(C[i] + F[i-2], F[i-1])
    return F[n]
```

### 找零问题

-   找零问题：n 种面值硬币，面值满足 $d_1 < d_2 < \cdots < d_n$，其中 $d_1 = 1$，求完成找零 D 元所需的最小硬币数量

####    动态规划

$$
F(i) =
\left \{ \begin{array}{l}
    min \{ j: i \geqslant d_j \} \{ F(i - d_j) \} + 1 & i > 0 \\
    0 & i = 0
\end{array} \right.
$$

-   递推思路
    -   记 $F(i)$ 为找零额为 i 的数量最少的硬币数目，定义 $F(0)=0$
    -   得到找零额 i 的途径只能是在 $n - d_j$ 上加入面值为 $d_j$ 的硬币，其中 $j=1, 2, \cdots, m$，且 $i \geqslant d_j$
    -   考虑所有满足条件 $d_j$，选择使得且 $F(n - d_j)$ 最小者

```c
ChangeMaking(D[1..m], n)
    // 动态规划法求解找零问题，d_1 = 1
    // 输入：正整数n，币值数组D[1..m]
    // 输出：总金额为n的最少硬币数目
    F[0] = 0
    for i = 1 to n do
        tmp = \infty
        j = 1
        while j <= m and i >= D[j] do
            tmp = min(F[i-D[j], tmp)
            j += 1
        F[i] = tmp + 1
    return F[n]
```

###    硬币收集问题

-   硬币收集问题：在 $n * m$ 格木板中存放有硬币，每格硬币最多一个，寻找左上角 $(1,1)$ 到右下角 $(n, m)$ 路径，使得能够收集尽可能多硬币，每次只能向下、向右移动

####    动态规划

$$
F(i, j) =
\left \{ \begin{array}{l}
    max \{F(i-1 ,j), F(i, j-1)\} + c_{ij} & 1 <= i <= n, i <= j <= m \\
    0 & i = 0 or j = 0
\end{array} \right.
$$

-   递推思路
    -   记 $F(i, j)$ 为截止到第 i 行、第 j 列 $(i, j)$ 时能够收集到最大硬币数
        -   初值设置：假定 $F(0, j)=0, F(i, 0)=0$
    -   单元格$(i, j)$ 只能经由 $(i-1, j)$、$(i, j-1)$ 达到
        -   递推求解 $F[1, j], F[i, 1]$
-   算法效率
    -   计算每个单元格 $F[i, j]$ 花费常量时间，算法时间效率 $\in \Theta(nm)$
    -   算法空间效率 $\in Theta(nm)$

```c
CoinCollection(C[1..n, 1..m])
    // 动态规划算法求解硬币收集问题
    // 输出：矩阵C[1..n, 1..m]表示单元格是否有硬币
    // 输出：在单元格[n, m]能够收集到的最大硬币数
    F[1, 1] = C[1, 1]
    for j = 2 to m do
        F[1, j] = F[1, j-1] + C[1, j]
        // 初始化首行
    for i = 2 to n do
        F[i, 1] = F[i-1, 1] + C[i, 1]
        for j = 2 to n do
            // 先填列
            F[i, j] = max(F[i-1, j], F[i, j-1]) + C[i, j]
    return F[n, m]
```

### n 皇后问题

-   n 皇后问题：将 n 个皇后放在 $n * n$ 的棋盘上，使得皇后之间不能相互攻击

> - 位运算求解 n 皇后问题：<https://zhuanlan.zhihu.com/p/22846106>

### 球桶问题

-   n 球放入 m 桶的不同情况数量
    -   约束：球同、桶不同、无空桶
        -   插板法
            $$\left \{ \begin{array}{l}
                C_{n-1}^{m-1}, & n \geq m \\
                0, & n < m
            \end{array} \right.$$
    -   球同、桶不同、可空桶
        -   插板法：假设 m 个桶中已经放好球，即 m+n 个相同球放入 m 个不同桶、不允许空桶
            $$ C_{n+m-1}^{m-1} $$
    -   球同、桶同、可空桶
        -   动态规划：球数 $i \geq j$ 桶数时递推式
            $$dp_4[i][j] = \left \{ \begin{array}{l}
                dp_4[i][j-1] + dp_4[i-j][j], & i \geq j \\
                dp_4[i][j-1], & i < j \\
            1, & i=1,0 or j=1
            \end{array} \right.$$
            -   若有桶均包含球：剩余球可能性 $dp[i-j][j]$
            -   若存在桶不包含球：剔除一个桶不影响总数
            -   没有其余情况
    -   球同、桶同、无空桶
        -   动态规划：由 $dp_4$ 得到
            $$dp_5[i][j] = \left \{ \begin{array}{l}
                dp_4[i-j][j], & i \geq j \\
                0, & i < j
            \end{array} \right.$$
    -   球不同、桶同、无空桶
        -   动态规划：第二类斯特林数，球数 $i>j$ 桶数时递推式
            $$dp[i][j] = \left \{ \begin{array}{l}
                j*dp[i-1][j] + dp[i-1][j-1], & 1 \leq j < i \\
                1, & i = j \\
                0, & i < j
            \end{array} \right.$$
            -   考虑前 $i-1$ 球已经占满所有桶，则最后球放入任何桶都是新情况
            -   考虑前 $i-1$ 只占满 $j-1$ 个桶，则最后球必须放入空桶
            -   其他情况不可能
    -   球不同、桶同、可空桶
        -   在 **球不同、桶同、无空桶** 情况下 **枚举** 不空桶数目
            $$ dp_2[i][j] = \sum_{k=1}^j dp[i][j] $$
    -   球不同、桶不同、无空桶
        -   在 **球不同、桶同、无空桶** 情况下对桶排序
            $$ dp_3[i][j] = dp[i][j] * (j!) $$
    -   球不同、桶不同、可空桶
        -   每个球都有 m 种选择：$m^n$

### 生成全排列

-   生成全排列
    -   按最小变化顺序生成
        -   假设 $(n-1)!$ 个排列已经生成
        -   将第 n 元素插入 n-1 个元素排列种中可能的 n 个位置中去，得到较大规模问题的解
    -   按字典序生成
        -   找到序列中最长递减后缀 $a_{i+1} > a_{i+2} > \cdots > a_{n}$
        -   将 $a_i$ 同序列中大于其的最小元素交换
        -   将新后缀颠倒，使其变为递增序列，加入列表中

### 生成子集

-   生成子集
    -   按字典序生成
        -   将正序 ${1, \cdots, n}$ 转换为二进制位串
        -   依次按照二进制位串生成子集
            -   位串中为 1 表示对应元素在子集中
    -   按挤压序生成：包含 $a_j$ 子集必须紧排在所有包含 $a_1, \cdots, a_{j-1}$ 子集之后
        -   将倒序 ${n, \cdots, 1}$ 转换为二进制位串
        -   依次按照二进制位串生成子集
            -   位串中为 1 表示对应元素在子集中
    -   按最小变化生成
        -   每个子集和其直接前趋之间，要么增加一个元素，要么减少一个元素
        -   即每个位串和直接前趋之间仅仅相差一位

##  几何问题

-   几何问题：处理类似于点、线、多面体这样的几何对象
    -   典型问题
        -   最近对问题：平面上的 n 个点，求点集中距离最近的两个点
        -   凸包问题：平面上 n 个点，求包含点集的最小凸多边形
        -   欧几里得最小生成树：平面上 n 个点，构造顶点为这 n 个点的总长度最小的树
    -   解决思路
        -   分治法：减少搜索空间

### 最近对问题

-   最近对问题：平面上的 n 个点，求距离最近的两个点
    -   假设 n 个点按 X、Y 轴坐标依次升序排列
    -   应用
        -   聚类分析

####    分治法

-   分治思路
    -   在点集在 X 方向位置中位数 m 作垂线，将点集分成大小为 $\lceil n/2 \rceil, \lfloor n/2 \rfloor$ 两个子集 $P_l, P_r$
    -   子问题解：$d=min\{d_l, d_r\}$ 不一定是所有点对最小距离
    -   合并子问题解：最小距离点对仅需再考虑分界线 m 两侧、对称的 2d 垂直带中的点
        -   对带中点 $p_i$，只需考虑在其后、Y 坐标差小于 $d$ 矩形范围内点
            -   前序点遍历时已考虑
            -   $d$ 可用于限制搜索空间（剪枝）
        -   对带中每个点最多仅需考虑与 5 个点的距离，即矩形 4 顶点、对边中点
-   算法时间效率：在无特殊假设情况下的最好效率
    -   将问题划分为规模相同子问题、合并子问题解，算法都只需要线性时间
    -   运行时间递推式 $T(n) = 2T(n/2) + f(n)$，其中 $f(n) \in \Theta(n)$，则 $T(n) \in \Theta(nlogn)$

```c
EfficientClosestPair(P, Q)
    // 分治法解决最近点问题
    // 输入：P存储平面上n个点，按x轴坐标升序排列
            Q存储和P相同的n个点，按y坐标升序排列
    /// 输出：最近点直接欧几里得距离
    if n <= 3
        return 蛮力法最小距离
    else
        将P前ceiling(n/2)个点复制到P_l
        将Q相应的ceiling(n/2)点复制到Q_l
        将P余下floor(n/2)个点复制到P_r
        将Q余下floor(n/2)个点复制到Q_r

        d_l = EfficientClosestPair(P_l, Q_l)
        d_r = EfficientClosestPair(P_r, Q_r)
        d = min{d_l, d_r}

        m = P[ceiling(n/2) - 1].x
        将Q中所有|x-m|<d的点复制到数组S[0..num-1]

        dminsq = d^2
        for i=0 to num-2 do
            k = i+1
            while k <= num-1 and (S[k].y - S[i].y)^2 < dminsq
                dminsq = min((S[k].x - S[i].x)^2 + (S[k].y - S[i].y)^2, dminsq)
                k = k+1
    return sqrt(dminsq)
```

### 凸包问题

-   凸包问题：平面上 n 个点，求包含点集的最小凸多边形
    -   假设 n 个点按 X、Y 轴坐标依次升序排列
    -   凸多边形：对多边形任意边作两侧延长线，多边形均在延长线一侧
    -   应用
        -   计算机动画中使用凸包替换物体本身，加快碰撞检测速度
        -   车辆路径规划
        -   地理信息系统中根据卫星图像计算accessibility map
        -   数理统计中用于进行异常值检测
        -   计算点集直径

####    分治法（快包算法）

-   分治思路
    -   $p_1$、$p_n$ 显然是凸包顶点，且 $\overrightarrow{p_1p_n}$ 将点集分为上包 $S_1$、下包 $S_2$
        -   子问题解：连线即为上、下包凸包一边，剩余凸包边用相同的方法构造
        -   合并子问题解：连线上点不是凸包顶点，之后不必考虑
    -   以 $S_1$ 为例，类似可对 $S_2$ 寻找下包顶点
        -   中止条件：若 $S_1$ 为空，则上包就是线段 $p_1p_n$
        -   分治思路：寻找距离 $p_1p_n$ 最大点 $p_{max}$，即为上包顶点
            -   若存在多个，选择使得夹角 $\angle p_{max}p_1p_n$ 最大点
            -   不存在同时位于 $\overrightarrow{p_1p_{max}}$、$\overrightarrow{p_{max}p_n}$ 左侧的点
        -   子问题解：对 $\overrightarrow{p_1p_{max}}$ 及其左侧点构成的集合 $S_{1,1}$、$\overrightarrow{p_{max}p_n}$ 及其左侧的点构成集合 $S_{1,2}$，重复以上即可继续得到上包顶点
        -   合并子问题解：包含在 $\triangle p_1p_{max}p_2$ 中的点不是上包顶点，之后不必考虑
-   算法效率类似快排算法
    -   最差效率 $\Theta(n)$
    -   平均效率好得多，可把问题平均的分成两个较小子问题，提高效率
    -   对于均匀分布在某些凸区域（园、矩形）的点，快包平均效率可以达到线性

### 欧几里得最小生成树

-   欧几里得最小生成树：平面上 n 个点，构造顶点为这 n 个点的总长度最小的树
#TODO

##  图算法

-   图算法
    -   典型问题
        -   图遍历：访问到网络中所有节点
        -   最短路线：两个城市间最佳路线
        -   有向图拓扑排序：课程、预备课程是否有矛盾
        -   All-Pairs Shortest-Paths Problem：完全最短路径问题，找到
            每个顶点到其他所有顶点的距离

### 图遍历

####    *Depth-First Search*

-   *DFS* 深度优先查找
    -   从任意顶点开始访问图顶点，然后标记为已访问
    -   每次迭代时，紧接着处理与当前顶点邻接的未访问顶点，直到遇到终点，该顶点所有邻接顶点均已访问过
    -   在终点上，算法沿着来路后退一条边，继续从那里访问未访问顶点
    -   后退到起始点，且起始点也是终点时，算法停止，这样起始点所在的连通分量的所有顶点均已访问过
    -   若存在未访问顶点，则必须从其中任一顶点开始重复上述

```c
count = 0
    // 全局变量：访问次序（次数）
DFS(G)
    // 对给定图的深度优先查找遍历
    // 输入：图G=<V, E>
    // 输出：图G顶点按照DFS遍历第一次访问到的先后次序，
    //       未访问到标记未0
    for each vertex v in V do
        if v is marked with 0
            dfs(v)
dfs(v)
    // 递归访问所有和v相连接的未访问顶点，赋予count值
    count = count+1
    mark v with count
    for each vertex w in V adjecnt to v do
        if w is marked with 0
            dfs(w)
```

-   算法特点特点
    -   算法效率非常高效，消耗时间和表示图的数据结构规模成正比
        -   邻接矩阵：遍历时间效率 $\in \Theta(|V|^2)$
        -   邻接链表：遍历时间效率 $\in \Theta(|V|+|E|)$
    -   可以方便地用栈跟踪深度优先查找
        -   首次访问顶点，将顶点入栈
        -   当顶点成为终点时，将其出栈
        -   运行时就是实际上就是栈，所以深度优先可以直接利用递归实现
    -   DFS产生两种节点排列顺序性质不同，有不同应用
        -   入栈（首次访问顶点）次序
        -   出栈（顶点成为终点）次序
-   算法应用
    -   检查图连通性：算法第一次停止后，是否所有顶点已经访问
    -   检查图无环性：*DFS* 过程中是否包含回边
    -   *DAG* 拓扑排序：*DFS* 节点出栈逆序就是拓扑排序的一个解（图中无回边，即为有向无环图）

### *Broad-First Search*

-   *BFS* 广度优先查找：
    -   首先访问所有和初始顶点邻接的顶点
    -   然后是离它两条边的所有未访问顶点
    -   以此类推，直到所有与初始顶点在同一连通分类顶点均已访问
    -   若存在未访问顶点，从图其他连通分量任意顶点开始

```c
count = 0
    // 全局变量：访问次序（次数）
BFS(G)
    // 给定图广度优先查找变量
    // 输入：图G=<V, E>
    // 输出：图G的顶点按照被BFS遍历第一次访问到次序，
    //       未访问顶点标记未0
    for each vertax v in V do
        if v is marked with 0
            bfs(v)
bfs(v)
    // 访问所有和v相连接的顶点，赋count值
    count = count+1
    whilte queue is not empty do
        for each vertex w in V adjcent to the front vertex do
            if w is marked with 0
                count = count+1
                mark w with count
                add w to the queue
        remove the front vertex from the queue
```

-   算法特点
    -   算法效率同 *DFS*
        -   邻接矩阵：遍历时间效率 $\in \Theta(|V|^2)$
        -   邻接链表：遍历时间效率 $\in \Theta(|V|+|E|)$
    -   使用队列可以方便地跟踪广度优先查找操作
        -   从遍历初始顶点开始，标记、入队
        -   每次迭代时，算法查找所有和队头顶点邻接未访问，标记、入队、将队头顶点出队
    -   *BFS* 只产生顶点的一种排序，因为队列是 *FIFO* 结构，顶点入队、出队次序相同
-   算法应用
    -   和 *DFS* 一样可以检查图的连通性、无环性，但是无法用于比较复杂的应用
    -   求给定两个顶点间最短路径：从一顶点开始 *BFS* 遍历，首次访问到另一节点结束

##  二进制位问题

-   位运算：移位、按位与或反
    -   依赖 2 进制计算硬件结构解决问题
        -   合并位遍历操作：转换为单次位运算
            -   变治解决子问题以降低整体复杂度
        -   复杂运算分解：转换为简单位运算

> - 位运算基础：<https://blog.51cto.com/u_15807491/5713218>
> - 位运算进阶：<https://www.cnblogs.com/CCJVL/p/10894615.html>
> - 位运算：<https://graphics.stanford.edu/~seander/bithacks.html>
> - 魔法数：<https://zhuanlan.zhihu.com/p/33543750>

### `1` 数量

> - 问题：统计 `unsinged` 二进制表示中 `1` 数量

####   仅遍历 `1`

```cpp
int population(unsigned int bits){
    int result = 0;
    while (bits != 0){
        // 消除最后 1
        bits &= bits - 1;
        ++result;
    }
    return result;
}
```

-   算法特点
    -   遍历减少：仅仅遍历无符号整形二进制表示中 `1` 次数
        -   `bits &= bits - 1` 将末尾 `1` 消除

####   分治+查表

```cpp
int * initialization(){
    int * table = new int[256];
    for (int i = 1; i < 256; i++){
        table[i] = (i & 0x1) + table[i >> 1];
    }
    return table;
}
int population(int bits, int * table){
    return table[bits & 0xff] +
        table[(bit >> 8) & 0xff] +
        table[(bit >> 16) & 0xff] +
        table[(bit >> 24) & 0xff]
}
```

-   思路
    -   建表：为 8bits 数建立 256 长度的 `1` 数量表
        -   递推建立：`f(n) = f(n >> 1) + last_bit(n)`
    -   分治：将无符号整型分4块查表、加和结果

####   分治

```cpp
int population(unsigned int bits){
    // 分组计算
    bits = (bits & 0x55555555) + ((bits >> 1) & 0x55555555);
    bits = (bits & 0x33333333) + ((bits >> 2) & 0x33333333);
    bits = (bits & 0x0f0f0f0f) + ((bits >> 4) & 0x0f0f0f0f);
    bits = (bits & 0x00ff00ff) + ((bits >> 8) & 0x00ff00ff);
    bits = (bits & 0x0000ffff) + ((bits >> 16) & 0x0000ffff);
    return bits;
}
```

![unsigned_population__division](imgs/unsigned_population_division.png)

-   分治统计：依次将相邻 2bits、 4bits 分组，计算组内 `1`数量
    -   移位、求并：将组内无效 bits 置 `0`、并对齐
    -   `+`：计算组内 `1` 数量
        -   `0x0 + 0x0 = 0x0`
        -   `0x0 + 0x1 = 0x1`
        -   `0x1 + 0x1 = 0x10`：进位，符合逻辑
-   改进：考虑避免不必要的 `&`
    -   根据进位特性替换 2bits 组对应语句
    -   考虑组内空位是否可容纳 `+` 后结果
        -   8bits 组：有效半组 4bits 足够存储中的最大 `1` 数量 8，但无法存储 16 或更大，需要及时置空无效 bit
        -   16bits 组及之后：有效半组足够存储最大 `1` 数量 32，可以计算完之后再取值

```cpp
int population(unsigned int bits){
    // 等于上述首行
    bits = bits - ((bits >> 1) & 0x55555555);
    bits = (bits & 0x33333333) + ((bits >> 2) & 0x33333333);
    // 4bits 足够存储组内 8bits 中 `1` 最大数量 8
    bits = (bits + (bits >> 4)) & 0x0f0f0f0f;
    // 8bits 足够存储全部 32bits 中 `1` 最大数量 32
    bits = bits + (bits >> 8);
    bits = bits + (bits >> 16);
    return bits & 0x3f
}
```
 
### 整形中 `1` 数量奇偶性

-   问题：统计 `unsigned` 中 `1` 数量奇偶性

```cpp
// 原始版本
unsigned char parity(unsigned int i){
    // 相邻2bit一组异或确定奇偶
    i = i ^ (i >> 1);
    // 相邻4bit一组，依赖以上结果确定奇偶
    i = i ^ (i >> 2);
    i = i ^ (i >> 4);
    i = i ^ (i >> 8);
    i = i ^ (i >> 16);
    // 奇偶性保存在最后1bit，取出
    return i & 0x1;
}
```

-   分治统计：依次将相邻 2bits、 4bits 分组，统计组内奇偶性
    -   分组方式顺序调换仅影响中间结果中存放奇偶性统计结果 bits 位置
        -   奇偶性统计结果存放在组内最后 bit
        -   其中每次分组统计事实上都是统计 2bits 的奇偶性

```cpp
// 改进版本
unsigned char parity_k(unsigned int i){
    // 将存储奇偶性 bits 移至最后
    i = i ^ (i >> 4);
    i = i ^ (i >> 8);
    i = i ^ (i >> 16);
    // 查表得到结果
    return (0x6996 >> (i & 0x0f )) & 0x01;
}
```

-   在分治基础上查表
    -   调整分组顺序，将存储奇偶性 bits 位置移至最后
    -   计算奇偶性 bits 对应奇偶性表，查表得到结果
        -   一般可以设置长度为 `0x0f` 长度的数组，其中取值为索引奇偶性
        -   `0x6996` 即为对应奇偶性表，其中各位序 bit 取值为位序值对应的奇偶性

### 奇偶性填充

-   问题：将 `unsigned char` 中最高位作为校验位，保证整体的二进制标表示的奇偶性

```cpp
unsigned char even(unsigned char i){
    return ((i * 0x10204081) & 0x888888ff) % 1920;
}
unsigned char odd(unsigned char i){
    return ((i * 0x00204081) | 0x3DB6DB00) % 1152;
}
```

-   各数字二进制含义（设 `i` 的二进制表示为 `abcdefg`）
    -   `0x10204081 * i` 得到 `i` 二进制重复 5 次（溢出被截断）
    -   `0x888888ff &` 抽取所需 bits `d000a000e000b000f000c000gabcdefg`
    -   `1920 = 15 * 128`：对其取模即得到`[X]abcdefg`
        （将被除数表示为 16 进制分块可证）

### 位元反序

-   问题：反序 6bits 长整形二进制

```cpp
unsigned char revert(unsigned char i){
    return ((i * 0x00082082) & 0x01122408) % 255;
}
```

-   各数字二进制含义（设 `i` 的二进制表示为 `abcdef`）
    -   `0x00082082 * i` 得到 `i` 二进制重复 4 次
    -   `0x01122408 &` 抽取所需 bits `0000000a000e00b000f00c000000d000`
    -   对 `255` 取模即得到反序*（将被除数表示为 256 进制分块可证）

### 前导 `0`

-   问题：获取 `unsigned` 的二进制表示中前导 `0` 数量

```cpp
unsigned char nlz(unsigned int i){
    static unsigned char table[64] = {
        32, 31, 'u', 16, 'u', 30, 3, 'u', 15, 'u', 'u', 'u', 29,
        10, 2, 'u', 'u', 'u', 12, 14, 21, 'u', 19, 'u', 'u', 28,
        'u', 25, 'u', 9, 1, 'u', 17, 'u', 4, 'u', 'u', 'u', 11,
        'u', 13, 22, 20, 'u', 26, 'u', 'u', 18, 5, 'u', 'u', 23,
        'u', 27, 'u', 6, 'u', 24, 7, 'u', 8, 'u', 0, 'u'
    }

    i = i | (i >> 1);
    i = i | (i >> 2);
    i = i | (i >> 4);
    i = i | (i >> 8);
    i = i | (i >> 16);
    i = i * 0x06eb14f9;
    return table[i >> 26];
}
```

-   映射、查表
    -   移位取或：将最高位 `1` 传播至所有低位，原始值映射至 33 种取值
    -   `0x06eb14f9`：将 33 种值映射为低 6 位取值均不同值
        -   此类数的共同特点是因子均为 $2^k \pm 1$
            （此类数乘法容易通过移位操作实现）
        -   最小的此性质的数为 `0x45bced1 = 17 * 65 * 129 * 513`

##  二进制计算简化

### 俄式乘法

```c
RussianMul(x, y):
    ans = 0
    while x != 0:
        if x & 1 == 1:
            ans += y
        x >>= 1
        y <<= 1
    return ans
```

-   俄式乘法：计算两个正整数 n、m 相乘的非主流算法
    -   反复应用以下公式，简化每步的计算
        $$n * m = \left \{ \begin{array}{l}
            \frac n 2 * 2m + m, n = 2k + 1 \\
            \frac n 2 * 2m, n = 2k
        \end{array} \right.$$
    -   以 $1 * m$ 作为算法终止条件
    -   累加所有 n 为奇数步骤中的 m 即为最终结果

-   算法特点
    -   算法中只有折半、加倍、相加操作
        -   手动计算非常简便
        -   计算机硬件对折半、加倍只需要移位就可

> - 俄式乘法：<https://www.cnblogs.com/solititude/p/12551496.html>

### 快速幂

```c
LeftRightBinaryExponentiation(a, n):
    // 从左至右二进制幂算法计算 a^n
    // 输入：底数 a、幂次 n
    // 输出：a^n 的值
    ans = 1
    while n > 0:
        if n & 1:
            ans *= a
        a *= a
        n >>= 1
    return ans
```

-   二进制位串变治：将幂次转换为二进制位串，利用二进制位串简化计算
    -   计算二进制位串中为 1 对应幂次值
        -   `1`、`10`、`100`、`1000` 可由前次结果平方得到
    -   累乘即为结果
-   算法特点
    -   算法效率
        -   两个算法效率取决于位串长度，是对数级的

> - 快速幂：<https://zhuanlan.zhihu.com/p/95902286>

### 无符号整形除法

-   问题：将特定除数的除法转换为其他指令
-   思路：除数为常数时，用移位、乘法、加法替代除法运算
    -   常数除法（有符号或无符号）基本都有对应的乘法版本
    -   注意类型溢出

```cpp
// 除数为 3
unsigned div3(unsigned int i){
    // 在更高级别优化过程实际就会转化为类似指令
    // 但此语句可能会导致类型溢出
    return (i * 2863311531) >> 1;
}
```

$$\begin{align*}
2863311531 &= \frac {2^{33} + 1} 3 \\
i/3 &= \lfloor i * \frac {2^{33} + 1} 3 * \frac 1 {2^{33}} \rfloor \\
    &= \lfloor \frac i 3 + \frac i {3 * 2^{33}} \rfloor = \frac i 3
\end{align*}$$

> - 常量被除法：<https://zhuanlan.zhihu.com/p/151038723>

### 求平方根倒数

> - 问题：求 $\frac 1 {\sqrt x}$

```c
float i_sqrt(float a){
    union {
        int i;
        float x;
    };
    x = a;
    float ihalf = 0.5f * x;

    // 得到较好的初始估算值
    i = 0x5f000000 - (i >> 1);

    // 牛顿法迭代，可以重复以下语句多次提高精度
    x = x * (1.5f - ihalf * x * x);

    return x;
}
```

-   移位获取初始值
    -   考虑（规格化）单精度浮点数 $a$ 的二进制表示
        $$\begin{align*}
        a &= 2^{E-127} * (1+F) \\
        \frac 1 {\sqrt a} &= 2^{\frac {127 - E} 2 + 127} * (1+F)^{-\frac 1 2} \\
        &= 2^{190.5 - \frac E 2} * (1+F)^{-\frac 1 2}
        \end{align*}$$
    -   则 `0x5f000000 - (ii >> 1)` 可以满足指数部分得到近似结果 $190 - \frac E 2$
    -   其他细节使得存在比 `0x5f000000` 实践更优值，如：`0x5f375a86`
        -   规格化值的底数接近 1
        -   移位运算指数最后位部分移至尾数
        -   减法运算尾数部分向指数借位

-   牛顿法：$x_{n+1} = x_n - \frac {f(x_n)} {f^{'}(x_n)}$
    -   求 $\frac 1 {\sqrt x}$，即求 $f(x) = x^{-2} - a$ 零点
    -   则迭代为 $x_{n+1} = x_n(1.5 - 0.5 a x_n^2)$

> - <http://www.lomont.org/papers/2003/InvSqrt.pdf>
> - <https://zhuanlan.zhihu.com/p/33543750>

##  随机

### 均匀分布随机数
#TODO

#### 线性同余法

线性同余法：产生伪随机数最常用方法

$$\left \{ \begin{array}{l}
a_0 = & d \\
a_n = & (ba_{n-1} + c) % m, & n=1,2,\cdots
\end{array} \right.$$

> - $d \leq m$：随机序列种子
> - $b \geq 0, c \geq 0, m \geq 0$：关系到产生随机序列的随机性能
> > -   $m$：应该取得充分大
> > -   $gcd(m ,b)=1$：可以取 b 为素数

### *Monte Carlo*


### *Markow chain Monte Carlo*

##  数值运算

### 标量运算

-   整形无额外空交换
    -   异或
        ```cpp
        a = a^b
        b = a^b
        a = a^b
        ```
    -   加减：不考虑溢出
        ```cpp
        a = a+b
        b = a-b
        a = a-b
        ```

-   整形取整
    -   向下取整：`mid = (left + right) // 2`
    -   向上取整：`mid = (left + right + 1) // 2`

### 最大公约数、最小公倍数

```c
EuclidGCD(m, n)
    while n != 0 do
        r = m mod n
        m = n
        n = r
    return m
```

-   最大公约数
    -   辗转相除法：$gcd(m, n) = gcd(n, m mod n)$
-   最小公倍数：$lcm(m, n) = \frac {m * n} {gcd(m, n)}$

### 多项式求值

```c
Horner(P[0..n], x)
    // 用霍纳法则求多项式在给定点的值
    // 输入：多项式系数数组P[0..n]、数字x
    // 输出：多项式在x点的值
    p = P[n]
    for i = n-1 downto 0 do
        p = x*p + P[i]
    return p
```

-   霍纳法则：不断将未知数作为公因子提取出来，合并降次后的项，然后 计算多项式在特定点的值
-   算法特点
    -   时间效率始终为次数 n，只相当于直接计算中 $a_n x^n$ 的乘法数量

###    *Strassen* 矩阵乘法

$$\begin{align}
\begin{bmatrix}
C_{00} & C_{01} \\
C_{10} & C_{11}
\end{bmatrix}
    & =
\begin{bmatrix}
A_{00} & A_{01} \\
A_{10} & A_{11}
\end{bmatrix}
\begin{bmatrix}
B_{00} & B_{01} \\
B_{10} & B_{11}
\end{bmatrix} \\
    & =
\begin{bmatrix}
M_1+M_2-M_5+M_7 & M_3+M_5 \\
M_2+M_4 & M_1+M_3-M_2+M_6
\end{bmatrix} \\

M_1 & = (A_{00} + A_{11}) · (B_{00} + B_{11}) \\
M_2 & = (A_{10} + A_{11}) · B_{00} \\
M_3 & = A_{00} · (B_{01} - B_{11}) \\
M_4 & = A_{11} · (B_{10} - B_{00}) \\
M_5 & = (A_{00} + A_{01}) · B_{11} \\
M_6 & = (A_{10} - A_{00}) · (B_{00} + B_{01}) \\
M_7 & = (A_{01} + A_{11}) · (B_{10} + B_{11}) \\
\end{align}$$

-   *Strassen* 矩阵乘法
    -   将 A、B、均分块为 4 个 n/2 子矩阵
        -   A、B 是两个 n 阶方阵，若 n 不是 2 幂次，考虑填充 0
    -   递归使用 *Strassen* 方程中定义的矩阵M进行计算计算C各个子阵
-   算法特点
    -   对 2 * 2 分块计算，*Strassen* 算法执行了 7 次乘法、18 次加减法，蛮力算法需要执行 8 次乘法、4 次加法
    -   算法效率：矩阵趋于无穷大时，算法表现出的渐进效率卓越
        -   乘法次数递推式：$M(n) = 7M(n/2), M(1) = 1$，则 $M(n) = 7^{log_2 n} = n^{log_2 7} \approx n_{2.807}$
        -   加法次数递推式：$A(n) = 7A(n/2) + 18(n/2)^2, A(1)=0$ ，则 $A(n) \in \Theta(n^{log_2 7})$
-   说明
    -   部分算法时间效率有 $\in \Theta(n^\alpha)$，最小能达到 2.376，但是这些算法乘法常量很大、算法复杂，没有实用价值
    -   矩阵乘法效率下界为 $n^2$，目前得到的最优效率和其还有很大距离


